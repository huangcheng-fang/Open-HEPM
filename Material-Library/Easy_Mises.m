%% Function Header Comment
% Developer: FANG Huangcheng @ PolyU
% Last updated: 2025-01-01
% Email: valy_f@bjtu.edu.cn;huangcheng.fang@polyu.edu.hk
% Website: https://www.researchgate.net/profile/Huangcheng-Fang
% Please do not remove this Header Comment under any circumstances, such as using or modifying this code, or convert this code to another programming language
%This code is automatically generated by EasyUmat.
%Before utilizing this code, users should verify its correctness.
%If this code is used for academic research or any other purpose, please provide appropriate citation or acknowledgment.
%EasyUmat is developed by Huangcheng FANG @ PolyU
%Email: valy_f@bjtu.edu.cn;huangcheng.fang@polyu.edu.hk
%Website: https://www.researchgate.net/profile/Huangcheng-Fang
%============================Input parameter===============================
%elasPara: nx1 vector
%plasPara: nx1 vector
%hardPara: [ ]
%histPara:  nx1 vector
%stress: 6x1 vector,[Sx;Sy;Sz;Sxy;Syz;Szx]
%pstrain(plastic strain): 6x1 vector,[PEx;PEy;PEz;PExy;PEyz;PEzx]
%dstrain(strain increment): 6x1 vector,[dEx;dEy;dEz;dExy;dEyz;dEzx]
%==============================Output parameter============================
%Dct(Consistent tangent matrix): 6x6 matrix
%stress: 6x1 vector,[Sx;Sy;Sz;Sxy;Syz;Szx]
%pstrain(plastic strain): 6x1 vector,[PEx;PEy;PEz;PExy;PEyz;PEzx]
%histPara: nx1 vector
%===============================Method=====================================
%Implicit return algorithm; Backward Euler Method
%==========================================================================
%Please do not delete the above text at any time, such as using, modifying, or referencing this code
 
function [stress,Dct,pstrain,histPara]=Easy_Mises(elasPara,plasPara,histPara,otherPara,stress,pstrain,dstrain)
%========================Initialize input parameters=======================
E=elasPara(1); niu=elasPara(2);  
k=plasPara(1); n=plasPara(2); c0=plasPara(3); 
PEEQ0=histPara(1);
% PEEQ0=Get_equivalent_strain(pstrain);

%======================Initialize stress and strain=======================
PEx0=pstrain(1); PEy0=pstrain(2); PEz0=pstrain(3);
PExy0=pstrain(4); PEyz0=pstrain(5); PEzx0=pstrain(6);

%========================Update user-defined constant======================

%===========================Update elastic stress==========================
dpstrain=zeros(6,1);
[dsigma,D_elastic]=linear_elastic(E,niu,dstrain-dpstrain);
stress_predict=stress+dsigma;

%=====================Update variables related to stress===================
Sx=stress_predict(1); Sy=stress_predict(2); Sz=stress_predict(3);
Sxy=stress_predict(4); Syz=stress_predict(5); Szx=stress_predict(6);
I1=Sx+Sy+Sz; Sm=I1/3;
sx=Sx-Sm; sy=Sy-Sm; sz=Sz-Sm; sxy=Sxy; syz=Syz; szx=Szx;
J2=0.5*(sx.^2+sy.^2+sz.^2)+sxy.^2+syz.^2+szx.^2;

%=====================Update user-defined stress variables=================

%=====================Update user-defined strain variables=================
dPEEQ=0;

%=========================Update hardening parameters======================
c= k*(c0 +PEEQ0 + dPEEQ)^n;

%==========================Update yield function===========================
F=3^(1/2)*J2^(1/2) - c;
refF=c;

%=============================Elastic output===============================
if F<refF*1e-5
  stress=stress_predict;
  Dct=D_elastic;
  histPara(2)=c;
  return;
end

%============================Plastic calculation===========================
iternum=0;tol=1e-6;pLamda=0;HPara=[c;];
while true
% calculate derivatives of yield and potential functions
  dXFdS=[sx;
         sy;
         sz;
         2*sxy;
         2*syz;
         2*szx];
  dFdX=3^(1/2)/(2*J2^(1/2));
  dXGdS=[sx;
         sy;
         sz;
         2*sxy;
         2*syz;
         2*szx];
  dGdX=3^(1/2)/(2*J2^(1/2));
  dFdS=dXFdS*dFdX;
  dGdS=dXGdS*dGdX;
  dGdSx=dGdS(1); dGdSy=dGdS(2); dGdSz=dGdS(3);
  dGdSxy=dGdS(4); dGdSyz=dGdS(5); dGdSzx=dGdS(6);

% Calculate plastic strain
  dpstrain=pLamda*dGdS;

% Update user-defined strain variables
  dPEEQ=(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2)*pLamda;

% calculate 2nd derivative of potential functions
  ddGddX=-3^(1/2)/(4*J2^(3/2));
  ddXGddS1=[2/3, -1/3, -1/3, 0, 0, 0;
           -1/3, 2/3, -1/3, 0, 0, 0;
           -1/3, -1/3, 2/3, 0, 0, 0;
           0, 0, 0, 2, 0, 0;
           0, 0, 0, 0, 2, 0;
           0, 0, 0, 0, 0, 2];
  ddGddS=dXGdS*ddGddX*dXGdS.'+ddXGddS1*dGdX(1);

% calculate derivatives of hardening functions
  dFdH=-1;
  ddGdXdH=0;
  dH1dX=k*n*(c0 +PEEQ0 + dPEEQ)^(n - 1);
  dXH1d_dGdS=[-(2*pLamda*(dGdSy - 2*dGdSx + dGdSz))/(9*(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2)), -(2*pLamda*(dGdSx - 2*dGdSy + dGdSz))/(9*(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2)), -(2*pLamda*(dGdSx + dGdSy - 2*dGdSz))/(9*(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2)), (dGdSxy*pLamda)/(3*(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2)), (dGdSyz*pLamda)/(3*(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2)), (dGdSzx*pLamda)/(3*(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2))];
  dXH1dpLamda=(dGdSxy^2/3 + dGdSzx^2/3 + dGdSyz^2/3 + (2*(dGdSx - dGdSy)^2)/9 + (2*(dGdSx - dGdSz)^2)/9 + (2*(dGdSy - dGdSz)^2)/9)^(1/2);
  ddGdSdH=dXGdS*ddGdXdH;
  dHdS=[-dH1dX*dXH1d_dGdS*ddGddS;];
  dHdpLamda=[-dH1dX*dXH1dpLamda;];
  dHdH=eye(1)-[dH1dX*dXH1d_dGdS*ddGdSdH;];

% Calculate residuals
  [dsigma_corrected,D_elastic]=linear_elastic(E,niu,dstrain-dpstrain);
  sigma_res=dsigma_corrected-dsigma;
  HPara_res=[ k*(c0 +PEEQ0 + dPEEQ)^n-HPara(1);];

% Calculate tangent matrix
  Ktang=[eye(6)+pLamda*D_elastic*ddGddS, D_elastic*dGdS, pLamda*D_elastic*ddGdSdH; dFdS.',  0, dFdH; dHdS, dHdpLamda, dHdH];

% Convergence criterion
  if abs(F)/refF<tol&&norm(sigma_res)/norm(dsigma)<tol&&norm(HPara_res)/norm(HPara)<tol; break;end

% Update variables
  x=Ktang\[sigma_res;-F;HPara_res];
  dsigma=dsigma+x(1:6);
  pLamda=pLamda+x(7);
  HPara=HPara+x(8:end);
  c=HPara(1);
  stress_predict=stress+dsigma;

% Update variables related to stress
  Sx=stress_predict(1); Sy=stress_predict(2); Sz=stress_predict(3);
  Sxy=stress_predict(4); Syz=stress_predict(5); Szx=stress_predict(6);
  I1=Sx+Sy+Sz; Sm=I1/3;
  sx=Sx-Sm; sy=Sy-Sm; sz=Sz-Sm; sxy=Sxy; syz=Syz; szx=Szx;
  J2=0.5*(sx.^2+sy.^2+sz.^2)+sxy.^2+syz.^2+szx.^2;

% Update user-defined stress variables

% Update yield function
  F=3^(1/2)*J2^(1/2) - c;
  refF=c;

% Count
  iternum=iternum+1;
  if iternum>10000
    error('Material nonlinear iteration cannot converge in Easy_UMat')
  end
end

%=============================Plastic output==============================
stress=stress+dsigma;
pstrain=pstrain+dpstrain;
Dct=Ktang\[D_elastic;zeros(2,6)];
Dct=Dct(1:6,1:6);
Dct=Dct*0.7+D_elastic*0.3;
histPara(1)=histPara(1)+dPEEQ;
histPara(2)=c;
end

function [dsigmar,D_elastic]=linear_elastic(E,niu,dstrain)
LAM=E/(1+niu);
a=(1-niu)/(1-2*niu)*LAM;
b=niu/(1-2*niu)*LAM;
c=0.5*LAM;
D_elastic=[a, b, b, 0, 0, 0;
b, a, b, 0, 0, 0;
b, b, a, 0, 0, 0;
0, 0, 0, c, 0, 0;
0, 0, 0, 0, c, 0;
0, 0, 0, 0, 0, c;];
dsigmar=D_elastic*dstrain;
end

function pe=Get_equivalent_strain(strain)
pe=(strain(1)-strain(2)).^2+(strain(2)-strain(3)).^2+(strain(3)-strain(1)).^2+(strain(4).^2+strain(5).^2+strain(6).^2)*1.5;
pe=sqrt(2/9*pe);
end
